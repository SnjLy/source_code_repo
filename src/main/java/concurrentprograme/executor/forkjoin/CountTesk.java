package concurrentprograme.executor.forkjoin;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.Future;import java.util.concurrent.RecursiveTask;/** * Created by admin on 2017/5/19. */public class CountTesk extends RecursiveTask<Integer> {    private static final int THRESHOLD =2;    private int start;    private int end;    public CountTesk(int start, int end) {        this.start = start;        this.end = end;    }    /**     * The main computation performed by this task.     */    @Override    protected Integer compute() {        int sum =0;        boolean canComputer = (end -start)<= THRESHOLD;        if (canComputer) {            for (int i = start; i <= end; i++) {                sum += i;            }            System.out.println("task compute start:" + start + "+ end:" + end + "=" + sum);        }else {            int middle = (end + start) / 2;            CountTesk leftTask = new CountTesk(start, middle);            CountTesk rightTask = new CountTesk(middle+1, end);            leftTask.fork();            rightTask.fork();            int leftResult = leftTask.join();            int rightResult = rightTask.join();            sum = leftResult + rightResult;        }        return sum;    }    public static void main(String[] args) {        ForkJoinPool pool = new ForkJoinPool();        CountTesk tesk = new CountTesk(1,10);        Future<Integer> result = pool.submit(tesk);        //pool.execute(tesk);        try {            System.out.println(result.get());        } catch ( InterruptedException e ) {            e.printStackTrace();        } catch ( ExecutionException e ) {            e.printStackTrace();        }    }}