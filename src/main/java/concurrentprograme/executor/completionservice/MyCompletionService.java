package concurrentprograme.executor.completionservice;import java.util.concurrent.*;/** * Created by admin on 2017/5/17. */public class MyCompletionService {    public static void main(String[] args) {        ExecutorService executor = (ExecutorService)Executors.newCachedThreadPool();        CompletionService<String> service = new ExecutorCompletionService<String>(executor);        ReportRequest faceRequest=new ReportRequest("Face", service);        ReportRequest onlineRequest=new ReportRequest("Online",service);        Thread faceThread=new Thread(faceRequest);        Thread onlineThread=new Thread(onlineRequest);        ReportProcess process = new ReportProcess(service);        Thread senderThread=new Thread(process);        System.out.printf("Main: Starting the Threads\n");        faceThread.start();        onlineThread.start();        senderThread.start();        try {            System.out.printf("Main: Waiting for the report generators.\n");            faceThread.join();            onlineThread.join();        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.printf("Main: Shutting down the executor.\n");        executor.shutdown();        try {            executor.awaitTermination(1, TimeUnit.DAYS);        } catch (InterruptedException e) {            e.printStackTrace();        }        process.setEnd(true);        System.out.println("Main: Ends");    }    static class ReportGenerator implements Callable<String>{        private String title;        private String sender;        public ReportGenerator(String title, String sender) {            this.title = title;            this.sender = sender;        }        @Override        public String call() throws Exception {            try {                Long duration = (long) (Math.random() * 10);                System.out.printf("%s_%s: ReportGenerator: Generating a report during %d seconds\n", this.sender, this.title, duration);                TimeUnit.SECONDS.sleep(duration);            } catch ( InterruptedException e ) {                e.printStackTrace();            }            return title + ":" + sender;        }    }    static class ReportRequest implements Runnable{        private String name;        private CompletionService<String> service;        public ReportRequest(String name, CompletionService<String> service) {            this.name = name;            this.service = service;        }        @Override        public void run() {            ReportGenerator generator = new ReportGenerator(name, "report");            service.submit(generator);        }    }    static class ReportProcess implements Runnable{        private boolean end;        private CompletionService<String> service;        public ReportProcess(CompletionService<String> service) {            this.end = false;            this.service = service;        }        public void setEnd(boolean end) {            this.end = end;        }        @Override        public void run() {            while (!end){                try {                    Future<String> result = service.poll(20, TimeUnit.SECONDS);                    if (result != null) {                        String report = result.get();                        System.out.printf("ReportReceiver: Report Received:%s\n", report);                    }                } catch ( InterruptedException | ExecutionException e ) {                    e.printStackTrace();                }            }            System.out.printf("ReportSender: End\n");        }    }}