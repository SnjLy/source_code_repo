package concurrentprograme.executor;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.concurrent.*;/** * 执行者执行返回结果的任务 * <p> * Executor framework的一个优点是你可以并发执行返回结果的任务。Java并发API使用以下两种接口来实现： * <p> * Callable：此接口有一个call()方法。在这个方法中，你必须实现任务的（处理）逻辑。Callable接口是一个参数化的接口。意味着你必须表明call()方法返回的数据类型。 * Future：此接口有一些方法来保证Callable对象结果的获取和管理它的状态。 * <p> * Created by yehao on 2017/4/11. */public class FactorialCalculator implements Callable<Integer> {    private Integer number;    public FactorialCalculator(Integer number) {        this.number = number;    }    @Override    public Integer call() throws Exception {        int result = 1;        if (number == 1 || number == 0) {            result = 1;        } else {            for (int i = 2; i <= number; i++) {                result *= i;                TimeUnit.SECONDS.sleep(1);            }        }        System.out.printf("Thread:%s: %d !+= %d\n", Thread.currentThread().getName(), number, result);        return result;    }    public static void main(String[] args) {        //使用Executors类的newFixedThreadPool()方法创建ThreadPoolExecutor来运行任务。传入参数2。        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);        //创建Future<Integer>对象的数列。        List<Future<Integer>> resultList = new ArrayList<>();        //创建Random类产生的随机数。        Random random = new Random();        for (int i = 0; i < 10; i++) {            Integer number = random.nextInt(10);            //创建一个FactorialCaculator对象，传入随机数作为参数。            FactorialCalculator calculator = new FactorialCalculator(number);            //调用执行者的submit()方法来提交FactorialCalculator任务给执行者。这个方法返回Future<Integer>对象来管理任务，并且最终获取它的结果。            //它使用submit()方法提交一个Callable对象给执行者执行。这个方法接收Callable对象参数，并且返回一个Future对象            Future<Integer> result = executor.submit(calculator);            //添加Future对象到之前创建的数列。            resultList.add(result);        }        //创建一个do循环来监控执行者的状态。        do {            //首先，写入信息到控制台，表明使用执行者的getCompletedTaskNumber()方法获得的已完成的任务数。            System.out.printf("Main: Number of Completed Tasks:%d\n", executor.getCompletedTaskCount());            //然后，对于数列中的10个Future对象，使用isDone()方法，将信息写入（到控制台）表明它们所管理的任务是否已经完成            for (int i = 0; i < resultList.size(); i++) {                Future<Integer> result = resultList.get(i);                System.out.printf("Main: Task %d: %s\n", i, result.isDone());            }            //令这个线程睡眠50毫秒            try {                TimeUnit.MILLISECONDS.sleep(50);            } catch ( InterruptedException e ) {                e.printStackTrace();            }            //如果执行者中的已完成任务数小于10，重复这个循环。        } while (executor.getCompletedTaskCount() < resultList.size());        //将获得的每个任务的结果写入控制台。对于每个Future对象，通过它的任务使用get()方法获取返回的Integer对象。        System.out.printf("Main: Results\n");        for (int i = 0; i < resultList.size(); i++) {            Future<Integer> result = resultList.get(i);            Integer number = null;            try {                number = result.get();            } catch ( InterruptedException e ) {                e.printStackTrace();            } catch ( ExecutionException e ) {                e.printStackTrace();            }            //然后，在控制台打印这个数。            System.out.printf("Main: Task %d: %d\n", i, number);        }        //最后，调用执行者的shutdown()方法来结束这个执行者。        executor.shutdown();    }}