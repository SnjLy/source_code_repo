package concurrentprograme.executor;import java.util.concurrent.*;/** * 当你使用执行者执行并发任务时，你将会提交 Runnable或Callable任务给这个执行者，并获取Future对象控制这个方法。你可以发现这种情况，你需要提交任务给执行者在一个对象中， * 而处理结果在另一个对象中。基于这种情况，Java并发API提供CompletionService类。 * <p> * CompletionService 类有一个方法来提交任务给执行者和另一个方法来获取已完成执行的下个任务的Future对象。在内部实现中，它使用Executor对象执行任务。 * 这种行为的优点是共享一个CompletionService对象，并提交任务给执行者，这样其他（对象）可以处理结果。其局限性是，第二个对象只能获取那些已经完成它们的执行的任务的Future对象， * 所以，这些Future对象只能获取任务的结果。 * <p> * 在这个指南中，你将学习如何使用CompletionService类把执行者启动任务和处理它们的结果分开。 * Created by admin on 2017/4/17. */public class ReportGenerator implements Callable<String> {    //声明两个私有的、String类型的属性，sender和title，用来表示报告的数据。    private String sender;    private String title;    public ReportGenerator(String sender, String title) {        this.sender = sender;        this.title = title;    }    @Override    public String call() throws Exception {        long duration = (long) (Math.random()*10);        System.out.printf("%s_%s: ReportGenerator: Generating a report during %d seconds\n",this.sender,this.title,duration);        TimeUnit.SECONDS.sleep( duration);        String ret=sender+": "+title;        return ret;    }    public static void main(String[] args) {        //使用Executors类的newCachedThreadPool()方法创建ThreadPoolExecutor。        ExecutorService executor = (ExecutorService) Executors.newCachedThreadPool();        //创建CompletionService，使用前面创建的执行者作为构造器的参数。        CompletionService<String> service = new ExecutorCompletionService<>(executor);        //创建两个ReportRequest对象，并用线程执行它们。        ReportRequest faceRequest = new ReportRequest("Face", service);        ReportRequest onlineRequest = new ReportRequest("Online", service);        Thread faceThread = new Thread(faceRequest);        Thread onlineThread = new Thread(onlineRequest);        //创建一个ReportProcessor对象，并用线程执行它。        ReportProcessor processor = new ReportProcessor(service);        Thread senderThread = new Thread(processor);        System.out.printf("Main: Starting the Threads\n");        faceThread.start();        onlineThread.start();        senderThread.start();        //等待ReportRequest线程的结束。        try {            System.out.printf("Main: Waiting for the report generators.\n");            faceThread.join();            onlineThread.join();        } catch ( InterruptedException e ) {            e.printStackTrace();        }        //使用shutdown()方法关闭执行者，使用awaitTermination()方法等待任务的结果。        System.out.printf("Main: Shutting down the executor.\n");        executor.shutdown();        try {            executor.awaitTermination(1, TimeUnit.DAYS);        } catch ( InterruptedException e ) {            e.printStackTrace();        }        //设置ReportSender对象的end属性值为true，结束它的执行。        processor.setEnd(true);        System.out.println("Main: Ends");    }}//创建ReportRequest类，实现Runnable接口。这个类将模拟一些报告请求。class  ReportRequest implements Runnable{    //声明私有的、String类型的属性name，用来存储ReportRequest的名称。    private String name;    //声明私有的、CompletionService类型的属性service。CompletionService接口是个参数化接口，使用String类型参数化它。    private CompletionService<String> service;    public ReportRequest(String name, CompletionService<String> service) {        this.name = name;        this.service = service;    }    //实现run()方法。创建1个ReportGenerator对象，并使用submit()方法把它提交给CompletionService对象。    @Override    public void run() {        ReportGenerator reportGenerator=new ReportGenerator(name,"Report");        service.submit(reportGenerator);    }}//创建ReportProcessor类。这个类将获取ReportGenerator任务的结果，指定它实现Runnable接口。class ReportProcessor implements Runnable {    //声明一个私有的、CompletionService类型的属性service。由于CompletionService接口是个参数化接口，使用String类作为这个CompletionService接口的参数。    private CompletionService<String> service;    //声明一个私有的、boolean类型的属性end。    private boolean end;    public ReportProcessor(CompletionService<String> service) {        this.service = service;        end = false;    }    //实现run()方法。当属性end值为false，调用CompletionService接口的poll()方法，获取CompletionService执行的下个已完成任务的Future对象。    public void run() {        while (!end) {            try {                Future<String> result = service.poll(20, TimeUnit.SECONDS);                //然后，使用Future对象的get()方法获取任务的结果，并且将这些结果写入到控制台。                if (result != null) {                    String report = result.get();                    System.out.printf("ReportReceiver: Report Received:%s\n", report);                }            } catch ( InterruptedException | ExecutionException e ) {                e.printStackTrace();            }        }        System.out.printf("ReportSender: End\n");    }    //实现setEnd()方法，用来修改属性end的值。    public void setEnd(boolean end) {        this.end = end;    }}